-- Castbars/MSUF_CastbarDriver.lua
-- Step 14: Spawn + driver split.
-- Owns creation of Target/Focus castbar frames and the EventBus driver that creates them on login.
-- Keeps MSUF_Castbars.lua focused on runtime/update + reanchor/apply utilities.

-- -------------------------------------------------
-- Step 14: Driver-side cast-state change detector (max performance)
-- Avoid redundant :Cast() rebuilds when the cast state hasn't actually changed.
-- -------------------------------------------------
local function MSUF_Driver_StateChanged(frame, st)
    if not frame then return true end

    local active = (st and st.active) and true or false
    local lastActive = frame._msufLastCastActive
    if lastActive == nil or lastActive ~= active then
        frame._msufLastCastActive = active
        -- wipe last fields when transitioning to inactive so next active always casts
        if not active then
            frame._msufLastCastType = nil
            frame._msufLastSpellId = nil
            frame._msufLastStartMS = nil
            frame._msufLastEndMS = nil
            frame._msufLastNotInterruptible = nil
        end
        return true
    end

    if not active then
        return false
    end

    local castType = st.castType
    local spellId = st.spellId
    local startMS = st.startTimeMS
    local endMS = st.endTimeMS
    local notInt = st.isNotInterruptible

    if frame._msufLastCastType ~= castType then frame._msufLastCastType = castType; return true end
    if frame._msufLastSpellId ~= spellId then frame._msufLastSpellId = spellId; return true end
    if frame._msufLastStartMS ~= startMS then frame._msufLastStartMS = startMS; return true end
    if frame._msufLastEndMS ~= endMS then frame._msufLastEndMS = endMS; return true end
    if frame._msufLastNotInterruptible ~= notInt then frame._msufLastNotInterruptible = notInt; return true end

    return false
end

local function MSUF_Driver_CastIfChanged(frame, unit, force)
    if not frame then return end
    local engine = _G.MSUF_GetCastbarEngine and _G.MSUF_GetCastbarEngine()
    if not engine or not engine.BuildState then
        -- Fallback to old behavior: always cast without preState
        if frame.Cast then frame:Cast() end
        return
    end

    local st = engine:BuildState(unit or frame.unit, frame)
    if force or MSUF_Driver_StateChanged(frame, st) then
        if frame.Cast then
            frame:Cast(st) -- preState path (avoids duplicate UnitCastingInfo calls)
        end
    end
end

local addonName, ns = ...

-- Shared interrupt feedback hold duration (seconds). Keep boss/target/focus consistent.
_G.MSUF_INTERRUPT_FEEDBACK_DURATION = _G.MSUF_INTERRUPT_FEEDBACK_DURATION or 0.5


-- Step 5 (engine/state): driver-side safe fallback for enabled checks.
-- MSUF_IsCastbarEnabledForUnit is normally provided by MSUF_Castbars.lua, but this file can
-- receive events very early (or in partial-load scenarios). Avoid hard nil errors.
local function MSUF_Driver_IsCastbarEnabled(unit)
    unit = unit or ""
    local fn = _G.MSUF_IsCastbarEnabledForUnit
    if type(fn) == "function" then
        local ok, res = pcall(fn, unit)
        if ok and res ~= nil then
            return res
        end
    end

    if type(_G.MSUF_EnsureDB) == "function" then
        pcall(_G.MSUF_EnsureDB)
    end

    local g = (_G.MSUF_DB and _G.MSUF_DB.general) or nil
    if not g then
        return true
    end

    if unit == "player" then
        return g.enablePlayerCastbar ~= false
    elseif unit == "target" then
        return g.enableTargetCastbar ~= false
    elseif unit == "focus" then
        return g.enableFocusCastbar ~= false
    else
        -- Boss/pet/etc are handled in their respective modules; assume enabled to avoid breaking casts.
        return true
    end
end



-- Step 5 (perf, smoothness-safe): cache expensive UI calls.
-- Avoid repeated StatusBar:SetStatusBarColor with identical values.
function _G.MSUF_SetStatusBarColorIfChanged(sb, r, g, b, a)
    if not sb or not sb.SetStatusBarColor then return end
    if a == nil then a = 1 end

    -- Cache the "base" (non-derived) fill color for optional end-of-cast glow/fade.
    -- Callers that apply a derived color MUST set `sb._msufGlowSkipBase = true`
    -- while calling this helper, otherwise we'll overwrite the base color.
    if not sb._msufGlowSkipBase then
        local br, bg, bb, ba = sb._msufGlowBaseR, sb._msufGlowBaseG, sb._msufGlowBaseB, sb._msufGlowBaseA
        if br ~= r or bg ~= g or bb ~= b or ba ~= a then
            sb._msufGlowBaseR, sb._msufGlowBaseG, sb._msufGlowBaseB, sb._msufGlowBaseA = r, g, b, a
            -- Force the fade to recompute next tick when the base color changes.
            sb._msufGlowLastP = nil
        end
    end
    local lr, lg, lb, la = sb._msufLastColorR, sb._msufLastColorG, sb._msufLastColorB, sb._msufLastColorA
    if lr == r and lg == g and lb == b and la == a then return end
    sb._msufLastColorR, sb._msufLastColorG, sb._msufLastColorB, sb._msufLastColorA = r, g, b, a
    if type(_G.MSUF_FastCall) == "function" then
        _G.MSUF_FastCall(sb.SetStatusBarColor, sb, r, g, b, a)
    else
        sb:SetStatusBarColor(r, g, b, a)
    end
end

-- Step 4 (perf): Only refresh cached style/layout when global style rev changes.
-- This prevents expensive DB/font/anchor reads from running in hot update loops.
local function MSUF__MaybeRefreshStyleCache(frame)
    local fn = _G.MSUF_RefreshCastbarStyleCache
    if type(fn) ~= "function" then return end

    local rev = _G.MSUF_CastbarStyleRev
    if type(rev) ~= "number" then rev = 0 end

    if frame and frame.MSUF_castbarStyleRev ~= rev then
        frame.MSUF_castbarStyleRev = rev
        fn(frame)
    end
end

-- Player-only: Channel "haste" stripes (5 static lines whose POSITIONS shift with current player spell haste).
-- Secret-safe: uses only UnitSpellHaste + StatusBar width (no duration/timer math, no combat log).
-- NOTE: This is NOT real tick detection; it is a consistent visual indicator that compresses marker spacing with haste.
local function MSUF__IsChannelTickLinesEnabled()
    local g = (MSUF_DB and MSUF_DB.general) or nil
    if g and g.castbarShowChannelTicks == false then
        return false
    end
    return true
end

local function MSUF__EnsurePlayerChannelHasteStripes(frame)
    if not (frame and frame.unit == "player") then return end

    local sb = frame.statusBar
    if not (sb and sb.CreateTexture) then return end

    if frame._msufPlayerChannelStripes then return end

    local stripes = {}
    for i = 1, 5 do
        local t = sb:CreateTexture(nil, "OVERLAY")
        t:SetColorTexture(1, 1, 1, 1)
		-- Always fully visible (no progress-based reveal).
		if t.SetAlpha then t:SetAlpha(1) end
        t:SetWidth(2)
        t:SetPoint("TOP", sb, "TOP", 0, 0)
        t:SetPoint("BOTTOM", sb, "BOTTOM", 0, 0)
        t:Hide()
        stripes[i] = t
    end
    frame._msufPlayerChannelStripes = stripes

    if not frame._msufPlayerChannelStripesHooked and sb.HookScript then
        frame._msufPlayerChannelStripesHooked = true
        sb:HookScript("OnSizeChanged", function()
            -- Reposition on resize.
            if frame and frame._msufPlayerChannelStripes then
                frame._msufPlayerChannelStripesForce = true
            end
        end)
    end
end

local function MSUF__HidePlayerChannelHasteStripes(frame)
    local stripes = frame and frame._msufPlayerChannelStripes
    if not stripes then return end
    for i = 1, #stripes do
        local t = stripes[i]
        if t and t.Hide then t:Hide() end
    end
end

local function MSUF__UpdatePlayerChannelHasteStripes(frame, force)
    if not (frame and frame.unit == "player") then return end

    -- Respect the menu toggle; if disabled, force-hide stripes immediately.
    if not MSUF__IsChannelTickLinesEnabled() then
        MSUF__HidePlayerChannelHasteStripes(frame)
        frame._msufPlayerChannelStripesLastW = nil
        frame._msufPlayerChannelStripesLastFactor = nil
        return
    end

    -- Only on channels; never on empower.
    if not (frame.MSUF_isChanneled and not frame.isEmpower) then
        MSUF__HidePlayerChannelHasteStripes(frame)
        frame._msufPlayerChannelStripesLastW = nil
        frame._msufPlayerChannelStripesLastFactor = nil
        return
    end

    local sb = frame.statusBar
    if not (sb and sb.GetWidth) then return end

    MSUF__EnsurePlayerChannelHasteStripes(frame)
    local stripes = frame._msufPlayerChannelStripes
    if not stripes then return end

	local w = sb:GetWidth() or 0
	if w <= 1 then
		-- Bar width can be 0 on the very first frame; still show stripes immediately using a safe fallback
		-- and force a proper reposition on the next size update.
		w = frame._msufPlayerChannelStripesLastW or 200
		frame._msufPlayerChannelStripesForce = true
	end

    local haste = 0
    if type(UnitSpellHaste) == "function" then
        local ok, v = MSUF_FastCall(UnitSpellHaste, "player")
        if ok and type(v) == "number" then haste = v end
    end
    local factor = 1 + (haste / 100)
    if factor <= 0 then factor = 1 end

    if frame._msufPlayerChannelStripesForce then
        force = true
        frame._msufPlayerChannelStripesForce = nil
    end

    local lastW = frame._msufPlayerChannelStripesLastW
    local lastF = frame._msufPlayerChannelStripesLastFactor
    if not force and lastW == w and lastF == factor then
        return
    end
    frame._msufPlayerChannelStripesLastW = w
    frame._msufPlayerChannelStripesLastFactor = factor

    local rf = (frame._msufStripeReverseFill == true)
    local anchor = rf and "RIGHT" or "LEFT"

    -- Base divider 6 => 5 markers at 1/6..5/6 when haste==0. With haste, markers compress toward start.
    local div = 6
    for i = 1, 5 do
        local t = stripes[i]
        if t and t.SetPoint then
			if t.SetAlpha then t:SetAlpha(1) end
            local pos = (i / div) / factor
            if pos < 0.02 then pos = 0.02 end
            if pos > 0.98 then pos = 0.98 end
            local x = w * pos
            if rf then x = -x end
            t:ClearAllPoints()
            t:SetPoint("CENTER", sb, anchor, x, 0)
            t:Show()
        end
    end
end



-- Step 2 (DurationObjects): keep cast time text working without relying on secret duration values.
-- We derive remaining time from the StatusBar's animated value/min/max (timer-driven or manual).
local function MSUF__IsPlainNumber_SecretSafe(n)
    if type(n) ~= "number" then return false end
    -- Secret numbers can still report type=="number" but will throw on arithmetic/comparisons.
    local ok = pcall(function()
        local _ = n + 0
        local __ = (n > -1e308) -- force a comparison too
        return _ and __ ~= nil
    end)
    return ok
end

local function MSUF__ToNumber_SecretSafe(v)
    if v == nil then return nil end

    -- In Midnight/Beta, "secret numbers" can still report type(v) == "number" but will error on arithmetic/comparisons.
    -- Therefore: prefer ToPlain() when available, but STILL validate the result.
    if type(_G.ToPlain) == "function" then
        local ok, pv = pcall(_G.ToPlain, v)
        if ok then
            local n = tonumber(pv)
            if n ~= nil and MSUF__IsPlainNumber_SecretSafe(n) then
                return n
            end
        end
    end

    -- If it's a number, validate it via pcall arithmetic/comparison.
    if type(v) == "number" then
        if MSUF__IsPlainNumber_SecretSafe(v) then
            return v
        end
        return nil
    end

    -- Last resort: try tonumber on stringy values safely, then validate.
    local ok2, n2 = pcall(tonumber, v)
    if ok2 and n2 ~= nil and MSUF__IsPlainNumber_SecretSafe(n2) then
        return n2
    end
    return nil
end

local function MSUF__GetRemainingFromStatusBar(frame)
    local sb = frame and frame.statusBar
    if not (sb and sb.GetValue and sb.GetMinMaxValues) then return nil end

    local okV, v = MSUF_FastCall(sb.GetValue, sb)
    if not okV then return nil end

    local okMM, minV, maxV = MSUF_FastCall(sb.GetMinMaxValues, sb)
    if not okMM then return nil end

    v    = MSUF__ToNumber_SecretSafe(v)
    minV = MSUF__ToNumber_SecretSafe(minV)
    maxV = MSUF__ToNumber_SecretSafe(maxV)

    if not (v and minV and maxV) then return nil end
    local span = maxV - minV
    if not (type(span) == "number" and span > 0) then return nil end

    -- Heuristic: if value decreases across ticks, treat value as "remaining".
    -- Otherwise treat (max - value) as remaining. This handles differing timer directions.
    local last = frame._msufLastSBValue
    frame._msufLastSBValue = v
    local decreasing = (last ~= nil and v < (last - 0.0001))

    local rem = decreasing and (v - minV) or (maxV - v)
    if type(rem) ~= "number" then return nil end
    if rem < 0 then rem = 0 end
    return rem
end

function _G.MSUF_UpdateCastTimeText_FromStatusBar(frame)
    if not (frame and frame.timeText) then return end

    if not (type(MSUF_IsCastTimeEnabled) == "function" and MSUF_IsCastTimeEnabled(frame)) then
        MSUF_SetTextIfChanged(frame.timeText, "")
        return
    end

    local rem = MSUF__GetRemainingFromStatusBar(frame)
    if type(rem) == "number" then
        MSUF_SetCastTimeText(frame, rem)
    else
        MSUF_SetTextIfChanged(frame.timeText, "")
    end
end


-- Empower timeline helpers (non-player units)
-- In recent betas, enemy empower stage data is available via GetUnitEmpowerStageDuration/â€¦ for target/focus/boss.
-- The spellcast events may deliver a nil castGUID for these units, so we never key on castGUID.
local function MSUF_Empower_NormalizeSeconds(v)
    v = tonumber(v)
    if not v then return nil end
    if v > 20 then
        v = v / 1000
    end
    return v
end

local function MSUF_BuildEmpowerTimeline_NonPlayer(unit)
    local stageEnds = {}
    local totalStage = 0

    local function getStageDur(idx)
        if type(GetUnitEmpowerStageDuration) ~= 'function' then return nil end
        local ok, raw = MSUF_FastCall(GetUnitEmpowerStageDuration, unit, idx)
        if not ok then raw = nil end
        local d = MSUF_Empower_NormalizeSeconds(raw)
        if not d or d <= 0 then return nil end
        return d
    end

    local stageCount = nil
    if type(GetUnitEmpowerStageCount) == 'function' then
        local ok, c = MSUF_FastCall(GetUnitEmpowerStageCount, unit)
        if ok then
            c = tonumber(c)
            if c and c > 0 then stageCount = c end
        end
    end

    local zeroBased = (getStageDur(0) ~= nil)
    local base = zeroBased and 0 or 1

    if stageCount then
        for stage = 1, stageCount do
            local idx = zeroBased and (stage - 1) or stage
            local d = getStageDur(idx)
            if not d then break end
            totalStage = totalStage + d
            stageEnds[#stageEnds + 1] = totalStage
        end
    else
        for i = base, base + 9 do
            local d = getStageDur(i)
            if not d then break end
            totalStage = totalStage + d
            stageEnds[#stageEnds + 1] = totalStage
        end
    end

    local maxHold = 0
    if type(GetUnitEmpowerHoldAtMaxTime) == 'function' then
        local ok, raw = MSUF_FastCall(GetUnitEmpowerHoldAtMaxTime, unit)
        if not ok then raw = nil end
        maxHold = MSUF_Empower_NormalizeSeconds(raw) or 0
        if maxHold < 0 then maxHold = 0 end
    end

    local castTotal, castStartSec, castEndSec = nil, nil, nil
    if type(UnitCastingInfo) == 'function' then
        local ok, _, _, _, startMS, endMS = MSUF_FastCall(UnitCastingInfo, unit)
        if ok and startMS and endMS and endMS > startMS then
            castStartSec = startMS / 1000
            castEndSec   = endMS / 1000
            castTotal    = (endMS - startMS) / 1000
        end
    end


    -- If stage count is known but per-stage durations were unavailable (often first-seen/secret),
    -- approximate stage ends from the current cast window so the bar renders as empowered immediately.
    if stageCount and stageCount > 0 and #stageEnds == 0 then
        local baseTotal = castTotal
        if not baseTotal or baseTotal <= 0 then baseTotal = totalStage end
        if not baseTotal or baseTotal <= 0 then baseTotal = 3.0 end
        totalStage = baseTotal
        for i = 1, stageCount do
            stageEnds[i] = (baseTotal * i) / stageCount
        end
    end

    local totalBase = totalStage + maxHold

    if castTotal and castTotal > 0 then
        if totalBase <= 0 then
            totalBase = castTotal
        else
            if castTotal > totalBase then
                totalBase = castTotal
            end
        end

        if totalStage > 0 then
            local inferredHold = castTotal - totalStage
            if inferredHold < 0 then inferredHold = 0 end
            if maxHold <= 0 or math.abs((maxHold or 0) - inferredHold) > 0.15 then
                maxHold = inferredHold
            end
        end
    end

    if not totalBase or totalBase <= 0 then
        totalBase = 3.0
    end

    local totalWithGrace = totalBase
    if totalWithGrace <= 0 then totalWithGrace = 0.01 end

    return {
        stageEnds      = stageEnds,
        totalStage     = totalStage,
        maxHold        = maxHold,
        totalBase      = totalBase,
        totalWithGrace = totalWithGrace,
        castStartSec   = castStartSec,
        castEndSec     = castEndSec,
        castTotal      = castTotal,
        zeroBased      = zeroBased,
        stageCount     = stageCount,
    }
end

local function MSUF_ClearEmpowerState(frame)
    if not frame then return end
    frame.isEmpower = nil
    frame.empowerStartTime = nil
    frame.empowerStageEnds = nil
    frame.empowerTotalBase = nil
    frame.empowerTotalWithGrace = nil
    frame.empowerNextStage = nil
    frame.MSUF_empowerLayoutPending = nil
    frame.MSUF_wantsEmpower = nil
    frame.MSUF_empowerRetryCount = nil
    frame.MSUF_empowerRetryActive = nil

    if frame.empowerTicks then
        for i = 1, #frame.empowerTicks do
            local t = frame.empowerTicks[i]
            if t then
                t:Hide()
                if t.MSUF_glow then t.MSUF_glow:Hide() end
                if t.MSUF_flash then t.MSUF_flash:Hide() end
            end
        end
    end
    if frame.empowerSegments then
        for i = 1, #frame.empowerSegments do
            local s = frame.empowerSegments[i]
            if s then s:Hide() end
        end
    end
end

local function CreateCastBar(name, unit)
    local frame = CreateFrame("Frame", name, UIParent)
    frame:SetClampedToScreen(true)
    frame.unit = unit
    frame.reverseFill = false -- legacy flag; actual fill controlled via MSUF_GetCastbarReverseFill()

    function frame:UpdateColorForInterruptible()
        if not self or not self.statusBar or not self.statusBar.SetStatusBarColor then
            return
        end

        EnsureDB()
        local g = MSUF_DB and MSUF_DB.general or {}

        local isNonInterruptible = (self.isNotInterruptible == true)

        if not isNonInterruptible and C_NamePlate and C_NamePlate.GetNamePlateForUnit then
            local sec = (type(issecure) == "function") and issecure() or false
            local np = C_NamePlate.GetNamePlateForUnit(self.unit, sec)
            local bar = np and np.UnitFrame and np.UnitFrame.castBar
            local bt = bar and bar.barType
            if bt == "uninterruptible" or bt == "uninterruptable" or bt == "shielded" or bt == "shield" or bt == "uninterruptibleEmpowered" or bt == "uninterruptableEmpowered" or bt == "tradeskill" then
                isNonInterruptible = true
            end
        end

        local r, gg, b
        if isNonInterruptible then
            if MSUF_GetNonInterruptibleCastColor then
                r, gg, b = MSUF_GetNonInterruptibleCastColor()
            end
            if not (r and gg and b) then
                local key = g.castbarNonInterruptibleColor or "red"
                do
                local __c = (type(MSUF_GetColorFromKey) == "function") and MSUF_GetColorFromKey(key) or nil
                if __c and __c.GetRGB then
                    r, gg, b = __c:GetRGB()
                end
            end
            end
            if not (r and gg and b) then
                r, gg, b = 1, 0, 0
            end
        else
            if MSUF_GetInterruptibleCastColor then
                r, gg, b = MSUF_GetInterruptibleCastColor()
            end
            if not (r and gg and b) then
                local key = g.castbarInterruptibleColor or "turquoise"
                do
                local __c = (type(MSUF_GetColorFromKey) == "function") and MSUF_GetColorFromKey(key) or nil
                if __c and __c.GetRGB then
                    r, gg, b = __c:GetRGB()
                end
            end
            end
            if not (r and gg and b) then
                r, gg, b = 0.2, 0.8, 0.8
            end
        end

        _G.MSUF_SetStatusBarColorIfChanged(self.statusBar, r, gg, b, 1)
    end

    
    -- Step 8 (Engine integration): build cast state once (Unit APIs) and feed it into :Cast(state)
    -- so we don't call UnitCastingInfo/UnitChannelInfo twice per event/timer.
    local function MSUF_Driver_BuildCastStateFor(self)
        local E = (_G.MSUF_GetCastbarEngine and _G.MSUF_GetCastbarEngine()) or nil
        if E and E.BuildState then
            return E:BuildState(self.unit, self)
        end
        return nil
    end

    local function MSUF_Driver_CastResync(self)
        -- During INTERRUPTED feedback hold, ignore further resync events (STOP/CHANNEL_STOP etc.)
        -- so we don't clear the \"Interrupted\" text or restart timer-driven animations.
        if self.interrupted then
            return
        end
        local st = MSUF_Driver_BuildCastStateFor(self)
        self:Cast(st)
    end


    -- CHANNEL_STOP can fire as part of a "channel refresh" when the same spell is pressed again while channeling.
    -- In that case, UNIT_SPELLCAST_CHANNEL_START often follows immediately. If we treat CHANNEL_STOP as terminal
    -- instantly, target/focus bars will blink / end too early. However, on some builds UnitChannelInfo can also
    -- return stale data briefly after the channel actually ended, which can "restart" the bar if we resync.
    --
    -- Strategy:
    -- 1) On CHANNEL_START, bump a token.
    -- 2) On CHANNEL_STOP, queue a deferred confirm. If a new CHANNEL_START happened (token changed), we do nothing.
    -- 3) If the unit is still channeling (UnitChannelInfo), treat this as refresh/event-ordering and resync once;
    --    only hard-stop when channel info is absent after a short settle.
    local function MSUF_Driver_QueueChannelStopConfirm(self)
    if self._msufChStopQueued then return end
    self._msufChStopQueued = true

    local token = self._msufChToken or 0
    local unit  = self.unit

    local function confirm()
        if not self then return end

        -- New channel started since STOP (refresh / re-press while channeling) -> do nothing.
        if (self._msufChToken or 0) ~= token then
            return
        end

        -- Unit gone / invalid -> stop immediately.
        if not unit or (type(UnitExists) == "function" and not UnitExists(unit)) then
            self:SetSucceeded()
            return
        end

        -- If the unit is still channeling, we must NOT stop. This is either a refresh case or event ordering.
        -- We resync once to pick up the new channel window.
        if UnitChannelInfo(unit) then
            if self._msufChStopResyncToken ~= token then
                self._msufChStopResyncToken = token
                MSUF_Driver_CastResync(self)
            end
            return
        end

        self:SetSucceeded()
    end

    C_Timer.After(0, function()
        if not self then return end
        self._msufChStopQueued = nil

        -- Refresh already started -> resync to the newest channel immediately.
        if (self._msufChToken or 0) ~= token then
            MSUF_Driver_CastResync(self)
            return
        end

        -- Let UnitChannelInfo settle (can be stale / delayed for target/focus). Confirm across a short window.
        C_Timer.After(0.05, confirm)
        C_Timer.After(0.12, confirm)
        C_Timer.After(0.20, confirm)
        C_Timer.After(0.32, confirm)
        C_Timer.After(0.48, confirm)
        C_Timer.After(0.70, confirm)
    end)
end

frame:SetScript("OnEvent", function(self, event, arg1, ...)
        if not MSUF_Driver_IsCastbarEnabled(self.unit or "") then
            self:SetScript("OnUpdate", nil)
            if MSUF_UnregisterCastbar then
                MSUF_UnregisterCastbar(self)
            end
            self.MSUF_durationObj = nil
            self.MSUF_isChanneled = nil
            self.MSUF_channelDirect = nil
            self.MSUF_timerDriven = nil
            self.MSUF_timerRangeSet = nil
            self._msufLastSBValue = nil
            self.castDuration = nil
            self.castElapsed = nil
            if self.timeText then
                MSUF_SetTextIfChanged(self.timeText, "")
            end
            if self.latencyBar then
                self.latencyBar:Hide()
            end
            MSUF__HidePlayerChannelHasteStripes(self)
            self:Hide()
            return
        end

-- Empower events for non-player units can deliver a nil castGUID in current betas.
-- We track empower intent by event type only and fetch stage data via Unit APIs.
if event == "UNIT_SPELLCAST_EMPOWER_START" or event == "UNIT_SPELLCAST_EMPOWER_UPDATE" then
    self.MSUF_wantsEmpower = true
elseif event == "UNIT_SPELLCAST_EMPOWER_STOP" then
    self.MSUF_wantsEmpower = nil
elseif event == "UNIT_SPELLCAST_START" then
    -- Some betas delay EMPOWER_START or stage durations for enemy units on the first seen cast.
    -- Probe stage count to decide if this cast should enter empower mode immediately.
    self.MSUF_wantsEmpower = nil
    if type(GetUnitEmpowerStageCount) == "function" then
        local ok, c = MSUF_FastCall(GetUnitEmpowerStageCount, self.unit)
        if ok then
            c = tonumber(c)
            if c and c > 0 then
                self.MSUF_wantsEmpower = true
            end
        end
    end
elseif event == "UNIT_SPELLCAST_CHANNEL_START" then
    -- New non-empower channel: clear any prior empower state.
    self.MSUF_wantsEmpower = nil
end

        if event == "UNIT_SPELLCAST_START" or event == "UNIT_SPELLCAST_EMPOWER_START" then
            self.isNotInterruptible = false
            MSUF_Driver_CastResync(self)

		elseif event == "UNIT_SPELLCAST_DELAYED" or event == "UNIT_SPELLCAST_EMPOWER_UPDATE" then
			MSUF_Driver_CastResync(self)

		elseif event == "UNIT_SPELLCAST_CHANNEL_UPDATE" then
			-- UnitChannelInfo can momentarily return nil during channel refresh / event ordering for target/focus.
			-- Use the same deferred confirm logic as CHANNEL_STOP to avoid early abort, while still preventing stuck bars.
			if self.unit and not UnitChannelInfo(self.unit) then
				MSUF_Driver_QueueChannelStopConfirm(self)
				return
			end
			MSUF_Driver_CastResync(self)
		elseif event == "UNIT_SPELLCAST_STOP" or event == "UNIT_SPELLCAST_EMPOWER_STOP" or event == "UNIT_SPELLCAST_FAILED" then
	self:SetSucceeded()

elseif event == "UNIT_SPELLCAST_SUCCEEDED" then
    if self.unit == "player" then
        self:SetSucceeded()
    else
        MSUF_Driver_CastResync(self)
    end
elseif event == "UNIT_SPELLCAST_CHANNEL_START" then
            self._msufChToken = (self._msufChToken or 0) + 1
            self.isNotInterruptible = false
            MSUF_Driver_CastResync(self)

		elseif event == "UNIT_SPELLCAST_CHANNEL_STOP" then
            -- Deferred terminal: avoids early abort/blink on "channel refresh" (pressing the channel again)
            -- while still ensuring channels cannot keep running forever when STOP/INFO is stale.
            MSUF_Driver_QueueChannelStopConfirm(self)
            return

        elseif event == "UNIT_SPELLCAST_INTERRUPTIBLE" then
            if arg1 ~= self.unit then return end
            self.isNotInterruptible = false
            if self.UpdateColorForInterruptible then self:UpdateColorForInterruptible() end
            MSUF_Driver_CastResync(self)

        elseif event == "UNIT_SPELLCAST_NOT_INTERRUPTIBLE" then
            if arg1 ~= self.unit then return end
            self.isNotInterruptible = true
            if self.UpdateColorForInterruptible then self:UpdateColorForInterruptible() end
            MSUF_Driver_CastResync(self)

        elseif event == "UNIT_SPELLCAST_INTERRUPTED" then
            if arg1 ~= self.unit then return end
            self:SetInterrupted()

        elseif (event == "PLAYER_TARGET_CHANGED" and self.unit == "target")
            or (event == "PLAYER_FOCUS_CHANGED" and self.unit == "focus")
        then
            if self.timer then
                self.timer:Cancel()
                self.timer = nil
            end
            self.interrupted = nil
            MSUF_Driver_CastResync(self)
        end
    end)

    local function CreateCastFrame(self)
        if type(_G.MSUF_BuildCastbarFrameElements) == "function" then
            return _G.MSUF_BuildCastbarFrameElements(self)
        end
        if MSUF_DevPrint then MSUF_DevPrint("MSUF: MSUF_BuildCastbarFrameElements missing") end
    end

                -- Step 1 (cleanup): Legacy driver-side CastbarManager/update loop removed.
        -- The canonical CastbarManager + MSUF_RegisterCastbar/MSUF_UnregisterCastbar
        -- and MSUF_UpdateCastbarFrame live in MSUF_Castbars.lua.



function frame:Cast(preState)
        local spellName, text, texture, startTimeMS, endTimeMS
        local isChanneled = false
        local state = preState

        if state and state.active and state.unit == self.unit and state.spellName then
            spellName = state.spellName
            text = state.text or state.spellName
            texture = state.icon
            startTimeMS = state.startTimeMS
            endTimeMS = state.endTimeMS
            isChanneled = (state.castType == "CHANNEL")
        else
            spellName, text, texture, startTimeMS, endTimeMS = UnitCastingInfo(self.unit)
            if spellName == nil then
                spellName, text, texture, startTimeMS, endTimeMS = UnitChannelInfo(self.unit)
                isChanneled = (spellName ~= nil)
            end
        end

        if self.hideTimer and self.hideTimer.Cancel then
            self.hideTimer:Cancel()
            self.hideTimer = nil
        end

        if self.succeededTimer and self.succeededTimer.Cancel then
            self.succeededTimer:Cancel()
            self.succeededTimer = nil
        end

        local durationObj
        if state and state.durationObj ~= nil then
            durationObj = state.durationObj
        end
        -- IMPORTANT: do not clobber a valid durationObj with nil.
        -- Some builds (notably on target/focus during channel refresh) can return ok=true but d=nil for a tick.
        -- If we overwrite here, the castbar never shows until a later unrelated cast.
        if spellName then
            if isChanneled then
                if type(UnitChannelDuration) == "function" then
                    local ok, d = MSUF_FastCall(UnitChannelDuration, self.unit)
                    if ok and d ~= nil then durationObj = d end
                end
            else
                if type(UnitCastingDuration) == "function" then
                    local ok, d = MSUF_FastCall(UnitCastingDuration, self.unit)
                    if ok and d ~= nil then durationObj = d end
                end
            end
        end

-- Empowered casts for non-player units (target/focus/boss): build stage timeline and render like player.
-- We intentionally don't rely on castGUID because it can be nil on these units.
local isEmpower = false
local tl = nil
if spellName and self.MSUF_wantsEmpower and type(GetUnitEmpowerStageDuration) == "function" then
    tl = MSUF_BuildEmpowerTimeline_NonPlayer(self.unit)
    if tl and tl.stageEnds and #tl.stageEnds > 0 and tl.totalWithGrace and tl.totalWithGrace > 0 then
        isEmpower = true
    end
end

-- Retry a few times right after EMPOWER_START: stage durations can appear a tick later.
if spellName and self.MSUF_wantsEmpower and (not isEmpower) then
    self.MSUF_empowerRetryCount = (self.MSUF_empowerRetryCount or 0) + 1
    if self.MSUF_empowerRetryCount <= 6 and not self.MSUF_empowerRetryActive then
        self.MSUF_empowerRetryActive = true
        local token = (self.MSUF_empowerRetryToken or 0) + 1
        self.MSUF_empowerRetryToken = token
        C_Timer.After(0.05, function()
            if not self or token ~= self.MSUF_empowerRetryToken then return end
            self.MSUF_empowerRetryActive = nil
            if self.Cast then
                MSUF_Driver_CastResync(self)
            end
        end)
    end
elseif isEmpower then
    self.MSUF_empowerRetryCount = nil
    self.MSUF_empowerRetryActive = nil
end

if spellName and isEmpower and tl then
    self.interrupted = nil

    if self.icon and texture then
        self.icon:SetTexture(texture)
    end

    if self.castText then
        MSUF_SetTextIfChanged(self.castText, text or spellName or "")
    end

    -- Switch to empower mode (manual progression via MSUF_UpdateCastbarFrame)
    MSUF__HidePlayerChannelHasteStripes(self)
    self.isEmpower = true
    local now = (GetTimePreciseSec and GetTimePreciseSec()) or GetTime()
    local startSec = (tl.castStartSec or (startTimeMS and (startTimeMS / 1000))) or now
    self.empowerStartTime = startSec
    self.empowerStageEnds = tl.stageEnds
    self.empowerTotalBase = tl.totalBase
    self.empowerTotalWithGrace = tl.totalWithGrace
    -- Step 12: cache secret-safe numeric empower timing to avoid per-tick ToPlain/pcall work.
    -- These cached numbers are optional; tick code will fall back if nil.
    self._msufEmpowerStartNum = MSUF__ToNumber_SecretSafe(startSec) or now
    self._msufEmpowerTotalNum = MSUF__ToNumber_SecretSafe(self.empowerTotalWithGrace)
    self._msufEmpowerBaseNum  = MSUF__ToNumber_SecretSafe(self.empowerTotalBase) or self._msufEmpowerTotalNum

    local se = self.empowerStageEnds
    if type(se) == "table" then
        local t = self._msufEmpowerStageEndsNum
        if not t then t = {}; self._msufEmpowerStageEndsNum = t end
        for i = #t, 1, -1 do t[i] = nil end
        for i = 1, #se do
            local n = MSUF__ToNumber_SecretSafe(se[i])
            if type(n) ~= "number" then break end
            t[i] = n
        end
    else
        self._msufEmpowerStageEndsNum = nil
    end
    self.empowerNextStage = 1

    -- Apply reverse fill / timer direction based on the same rules we use for channels/empower.
    local rf = nil
    if state and state.reverseFill ~= nil then
        rf = state.reverseFill
    elseif type(_G.MSUF_BuildCastState) == "function" then
        local st = _G.MSUF_BuildCastState(self.unit, self)
        rf = st and st.reverseFill
    end
    if rf == nil then
        rf = (type(_G.MSUF_GetCastbarReverseFillForFrame) == "function" and _G.MSUF_GetCastbarReverseFillForFrame(self, true)) or false
    end
    rf = (rf == true)

    if self.statusBar then
        if type(_G.MSUF_ApplyCastbarTimerDirection) == "function" then
            -- durationObj may be nil for some enemy empower windows; direction still applies.
            _G.MSUF_ApplyCastbarTimerDirection(self.statusBar, durationObj, rf)
        elseif self.statusBar.SetReverseFill then
            MSUF_FastCall(self.statusBar.SetReverseFill, self.statusBar, rf)
        end

        if self.statusBar.SetMinMaxValues then
            self.statusBar:SetMinMaxValues(0, self._msufEmpowerTotalNum or self.empowerTotalWithGrace)
        end

        local elapsed0 = now - (self._msufEmpowerStartNum or self.empowerStartTime or now)
        if elapsed0 < 0 then elapsed0 = 0 end
        local total0 = self._msufEmpowerTotalNum or self.empowerTotalWithGrace
        if total0 and elapsed0 > total0 then elapsed0 = total0 end
        if self.statusBar.SetValue then
            self.statusBar:SetValue(elapsed0)
        end
    end

    self.MSUF_durationObj = nil
    self.MSUF_isChanneled = nil
    self.MSUF_channelDirect = nil
    self.MSUF_timerDriven = false
    self.MSUF_timerRangeSet = nil

        if _G.MSUF_ClearCastbarTimerDuration and self.statusBar then
            _G.MSUF_ClearCastbarTimerDuration(self.statusBar)
        end

        if self.statusBar and self.statusBar.SetMinMaxValues then
            pcall(self.statusBar.SetMinMaxValues, self.statusBar, 0, 1)
        end
        if self.statusBar and self.statusBar.SetValue then
            pcall(self.statusBar.SetValue, self.statusBar, 1)
        end

        local rf = MSUF_GetCastbarReverseFillForFrame(self, false)
        if _G.MSUF_ApplyCastbarTimerDirection then
            _G.MSUF_ApplyCastbarTimerDirection(self.statusBar, nil, rf)
        elseif _G.MSUF_SetStatusBarReverseFill then
            _G.MSUF_SetStatusBarReverseFill(self.statusBar, rf)
        elseif self.statusBar and self.statusBar.SetReverseFill then
            pcall(self.statusBar.SetReverseFill, self.statusBar, rf and true or false)
        end

        if self._msufCastState and self._msufCastState.unit == self.unit then
            self._msufCastState.durationObj = nil
        end

    self.castDuration = nil
    self.castElapsed = nil

    if self.UpdateColorForInterruptible then
        self:UpdateColorForInterruptible()
    end

    self.MSUF_empowerLayoutPending = true
    if type(_G.MSUF_LayoutEmpowerTicks) == "function" then
        _G.MSUF_LayoutEmpowerTicks(self)
    end

    self:SetScript("OnUpdate", nil)
    if MSUF_RegisterCastbar then
        MSUF_RegisterCastbar(self)
    end

    if self.timeText then
        if not MSUF_IsCastTimeEnabled(self) then
            MSUF_SetTextIfChanged(self.timeText, "")
        else
            local rem = (self.empowerTotalWithGrace or 0) - (elapsed0 or 0)
            if rem < 0 then rem = 0 end
            MSUF_SetCastTimeText(self, rem)
        end
    end

    self:Show()
    return
else
    -- Not in empower mode; ensure any leftover empower visuals are cleared.
    if self.isEmpower then
        MSUF_ClearEmpowerState(self)
    end
end

        if spellName and durationObj then
            self.interrupted = nil

            if self.icon and texture then
                self.icon:SetTexture(texture)
            end

            if self.castText then
                MSUF_SetTextIfChanged(self.castText, text or spellName or "")
            end

            self.MSUF_durationObj = durationObj
            self.MSUF_isChanneled = isChanneled

            -- Reset hard-stop persistence timers on a successful (re)start.
            self._msufHardStopNoChannelSince = nil
            self._msufHardStopNoCastSince = nil

            self.castDuration = nil
            self.castElapsed  = nil
            self.MSUF_timerDriven = nil
            self.MSUF_timerRangeSet = nil
            self._msufLastSBValue = nil
            self.MSUF_channelDirect = (isChanneled and (self.unit == "target" or self.unit == "focus")) and true or nil

            local okTimer = false
local __msuf_rf = nil
if type(_G.MSUF_BuildCastState) == "function" then
    local st = _G.MSUF_BuildCastState(self.unit, self)
    __msuf_rf = st and st.reverseFill
end
if __msuf_rf == nil then
    __msuf_rf = (type(_G.MSUF_GetCastbarReverseFillForFrame) == "function" and _G.MSUF_GetCastbarReverseFillForFrame(self, isChanneled)) or false
end
__msuf_rf = (__msuf_rf == true)

-- Player-only: remember reverseFill so stripe anchoring matches bar direction.
self._msufStripeReverseFill = __msuf_rf

-- Player-only: (re)compute channel haste stripes (positions depend on current haste + bar width).
MSUF__UpdatePlayerChannelHasteStripes(self, true)


if self.statusBar then
    if type(_G.MSUF_ApplyCastbarTimerDirection) == "function" then
        okTimer = _G.MSUF_ApplyCastbarTimerDirection(self.statusBar, durationObj, __msuf_rf)
    elseif type(_G.MSUF_SetStatusBarTimerDuration) == "function" then
        okTimer = _G.MSUF_SetStatusBarTimerDuration(self.statusBar, durationObj, __msuf_rf)
        if self.statusBar.SetReverseFill then
            MSUF_FastCall(self.statusBar.SetReverseFill, self.statusBar, (__msuf_rf and true or false))
        end
    elseif self.statusBar.SetTimerDuration then
        -- Cache which signature works (some builds expect a numeric direction, others a boolean).
        -- This avoids probing twice on every cast start.
        local mode = _G.__MSUF_TimerDurationMode
        if mode ~= nil then
            okTimer = MSUF_FastCall(self.statusBar.SetTimerDuration, self.statusBar, durationObj, mode)
        else
            okTimer = MSUF_FastCall(self.statusBar.SetTimerDuration, self.statusBar, durationObj, 0)
            if okTimer then
                _G.__MSUF_TimerDurationMode = 0
            else
                okTimer = MSUF_FastCall(self.statusBar.SetTimerDuration, self.statusBar, durationObj, true)
                if okTimer then
                    _G.__MSUF_TimerDurationMode = true
                end
            end
        end
        if self.statusBar.SetReverseFill then
            MSUF_FastCall(self.statusBar.SetReverseFill, self.statusBar, (__msuf_rf and true or false))
        end
    elseif self.statusBar.SetReverseFill then
        MSUF_FastCall(self.statusBar.SetReverseFill, self.statusBar, (__msuf_rf and true or false))
        okTimer = false
    end
end
self.MSUF_timerDriven = okTimer and true or false

            if self.UpdateColorForInterruptible then
                self:UpdateColorForInterruptible()
            end

            if MSUF_RegisterCastbar then
                MSUF_RegisterCastbar(self)
            end

            if self.timeText then
                _G.MSUF_UpdateCastTimeText_FromStatusBar(self)
            end

            self:Show()
        else
if self.hideTimer and self.hideTimer.Cancel then
    self.hideTimer:Cancel()
end

self.hideTimer = C_Timer.NewTimer(0, function()
    if not self or not self.unit then return end

    local st = MSUF_Driver_BuildCastStateFor(self)
if st and st.active then
    self:Cast(st)
    return
end

    self:SetScript("OnUpdate", nil)
    if MSUF_UnregisterCastbar then MSUF_UnregisterCastbar(self) end

    self.MSUF_durationObj = nil
    self.castDuration = nil
    self.castElapsed  = nil
    self.MSUF_timerDriven = nil
    self.MSUF_timerRangeSet = nil
    self.MSUF_isChanneled = nil
    self.MSUF_channelDirect = nil

    if self.timeText then
        MSUF_SetTextIfChanged(self.timeText, "")
    end
    if self.castText then
        MSUF_SetTextIfChanged(self.castText, "")
    end
    if self.latencyBar then
        self.latencyBar:Hide()
    end
    if not self.interrupted then
        self:Hide()
    end
end)
        end

        if self.timer then
            self.timer:Cancel()
            self.timer = nil
        end

        local grace = (_G.MSUF_INTERRUPT_FEEDBACK_DURATION or 0.5)

        if type(grace) ~= "number" then grace = 0.5 end
        if grace < 0 then grace = 0 end

        self.timer = C_Timer.NewTimer(grace, function()
            if self.interrupted then
                self.interrupted = nil
                self:Hide()
            end
        end)
    end

function frame:SetInterrupted()
    MSUF__HidePlayerChannelHasteStripes(self)

        if self.isEmpower then MSUF_ClearEmpowerState(self) end
        self:SetScript("OnUpdate", nil)
        if self.hideTimer and self.hideTimer.Cancel then
            self.hideTimer:Cancel()
            self.hideTimer = nil
        end
        if self.succeededTimer and self.succeededTimer.Cancel then
            self.succeededTimer:Cancel()
            self.succeededTimer = nil
        end
        if self.timer and self.timer.Cancel then
            self.timer:Cancel()
            self.timer = nil
        end
        if MSUF_UnregisterCastbar then MSUF_UnregisterCastbar(self) end
        self.MSUF_durationObj = nil
        self.MSUF_isChanneled = nil
        self.MSUF_channelDirect = nil
        self.MSUF_timerDriven = nil
        self.MSUF_timerRangeSet = nil

        if _G.MSUF_ClearCastbarTimerDuration and self.statusBar then
            _G.MSUF_ClearCastbarTimerDuration(self.statusBar)
        end
        self.castDuration = nil
        self.castElapsed = nil
        self.interrupted = true

        -- Respect per-unit "Show interrupt" toggle (hide interrupt feedback entirely when disabled).
        EnsureDB()
        local conf = (self.unit and MSUF_DB and MSUF_DB[self.unit]) or nil
        if conf and conf.showInterrupt == false then
            self.interrupted = nil
            if self.castText then
                MSUF_SetTextIfChanged(self.castText, "")
            end
            if self.timeText then
                MSUF_SetTextIfChanged(self.timeText, "")
            end
            self:Hide()
            return
        end


        if self.statusBar and self.statusBar.SetStatusBarColor then
            _G.MSUF_SetStatusBarColorIfChanged(self.statusBar, 1, 0, 0, 1)
        end

        if self.statusBar and self.statusBar.SetMinMaxValues then
            pcall(self.statusBar.SetMinMaxValues, self.statusBar, 0, 1)
        end
        if self.statusBar and self.statusBar.SetValue then
            pcall(self.statusBar.SetValue, self.statusBar, 1)
        end

        local rf = MSUF_GetCastbarReverseFillForFrame(self, false)
        if _G.MSUF_ApplyCastbarTimerDirection then
            _G.MSUF_ApplyCastbarTimerDirection(self.statusBar, nil, rf)
        elseif _G.MSUF_SetStatusBarReverseFill then
            _G.MSUF_SetStatusBarReverseFill(self.statusBar, rf)
        elseif self.statusBar and self.statusBar.SetReverseFill then
            pcall(self.statusBar.SetReverseFill, self.statusBar, rf and true or false)
        end

        if self.castText and self.castText.SetText then
            MSUF_SetTextIfChanged(self.castText, "Interrupted")
        end

        if self.timeText and self.timeText.SetText then
            MSUF_SetTextIfChanged(self.timeText, "")
        end

        self:Show()

        if MSUF_PlayCastbarShake then
            MSUF_FastCall(MSUF_PlayCastbarShake, self)
        end

        local grace = (_G.MSUF_INTERRUPT_FEEDBACK_DURATION or 0.5)

        if type(grace) ~= "number" then grace = 0.5 end
        if grace < 0 then grace = 0 end
        if self._msufCastState then
            local __t = (type(GetTime) == "function") and GetTime() or 0
            local __st = self._msufCastState
            __st.unit = self.unit
            __st.key = self._msufBarKey or self.unit
            __st.active = false
            __st.phase = "INTERRUPT"
            __st.durationObj = nil
            __st.holdUntil = __t + grace
        end

        self.hideTimer = C_Timer.NewTimer(grace, function()
            if not self or not self.unit then return end
            local st = MSUF_Driver_BuildCastStateFor(self)
            if st and st.active then
                self.interrupted = nil
                self:Cast(st)
                return
            end

            if self.interrupted then
                self.interrupted = nil
                self:Hide()
            end
        end)

    end

function frame:SetSucceeded()
    MSUF__HidePlayerChannelHasteStripes(self)

    -- If we're in interrupt feedback state, do NOT cancel the interrupt hold timer.
    -- Successful interrupts usually fire INTERRUPTED followed by STOP; STOP would call SetSucceeded.
    if self.interrupted then
        return
    end

        if self.isEmpower then MSUF_ClearEmpowerState(self) end
        self:SetScript("OnUpdate", nil)

        if self.hideTimer and self.hideTimer.Cancel then
            self.hideTimer:Cancel()
            self.hideTimer = nil
        end
        if self.succeededTimer and self.succeededTimer.Cancel then
            self.succeededTimer:Cancel()
            self.succeededTimer = nil
        end
        if self.timer and self.timer.Cancel then
            self.timer:Cancel()
            self.timer = nil
        end

        if MSUF_UnregisterCastbar then MSUF_UnregisterCastbar(self) end

        self.MSUF_durationObj = nil
        self.MSUF_isChanneled = nil
        self.MSUF_channelDirect = nil
        self.MSUF_timerDriven = nil
        self.MSUF_timerRangeSet = nil
        self.castDuration = nil
        self.castElapsed = nil

        if self.interrupted then return end

        if self.castText then
            MSUF_SetTextIfChanged(self.castText, "")
        end
        if self.timeText then
            MSUF_SetTextIfChanged(self.timeText, "")
        end

        self:Hide()
end

    frame:RegisterUnitEvent("UNIT_SPELLCAST_START", unit)
    frame:RegisterUnitEvent("UNIT_SPELLCAST_STOP", unit)
    frame:RegisterUnitEvent("UNIT_SPELLCAST_DELAYED", unit)

    frame:RegisterUnitEvent("UNIT_SPELLCAST_CHANNEL_START", unit)
    frame:RegisterUnitEvent("UNIT_SPELLCAST_CHANNEL_STOP", unit)
    frame:RegisterUnitEvent("UNIT_SPELLCAST_CHANNEL_UPDATE", unit)

    frame:RegisterUnitEvent("UNIT_SPELLCAST_EMPOWER_START", unit)
    frame:RegisterUnitEvent("UNIT_SPELLCAST_EMPOWER_STOP", unit)
    frame:RegisterUnitEvent("UNIT_SPELLCAST_EMPOWER_UPDATE", unit)

    frame:RegisterEvent("UNIT_SPELLCAST_INTERRUPTIBLE")
    frame:RegisterEvent("UNIT_SPELLCAST_NOT_INTERRUPTIBLE")

    frame:RegisterUnitEvent("UNIT_SPELLCAST_FAILED", unit)
    frame:RegisterUnitEvent("UNIT_SPELLCAST_SUCCEEDED", unit)
    frame:RegisterUnitEvent("UNIT_SPELLCAST_INTERRUPTED", unit)

    if unit == "target" or unit == "focus" then
        frame:RegisterEvent("PLAYER_" .. unit:upper() .. "_CHANGED")
    end

    local msufFrame = _G["MSUF_" .. unit]
    if msufFrame then
        frame:ClearAllPoints()
        if unit == "target" then
            frame:SetPoint("BOTTOMLEFT", msufFrame, "TOPLEFT", 0, 5)
        elseif unit == "focus" then
            frame:SetPoint("TOPLEFT", msufFrame, "BOTTOMLEFT", 0, -5)
        elseif unit == "player" then
            frame:SetPoint("BOTTOM", msufFrame, "TOP", 0, 5)
        else
            frame:SetPoint("CENTER", UIParent, "CENTER", 0, -300)
        end

        local w = msufFrame:GetWidth()
        if w and w > 0 then
            frame:SetWidth(w)
        end
    end

    CreateCastFrame(frame)
    frame:Hide()

    if unit == "target" then
        MSUF_TargetCastbar = frame
        _G.MSUF_TargetCastBar = frame
    elseif unit == "focus" then
        MSUF_FocusCastbar = frame
        _G.MSUF_FocusCastBar = frame
    elseif unit == "player" then
        MSUF_PlayerCastbar = frame
        _G.MSUF_PlayerCastBar = frame
    end

    return frame
end


function MSUF_EnsureCastbarManager()
    -- Step 1 (cleanup): no driver-side manager creation or Update wrapping.
    -- MSUF_Castbars.lua owns the manager. This function remains as a compatibility no-op.
    if MSUF_CastbarManager and MSUF_RegisterCastbar and MSUF_UnregisterCastbar and MSUF_UpdateCastbarFrame then
        return
    end
    -- If called before MSUF_Castbars.lua loads, it will become available later in the same addon.
end


MSUF_PlayerCastbar = MSUF_PlayerCastbar or nil -- forward declaration (shared global)


function MSUF_CastbarDriver_OnLogin(event)
        if not _G["TargetCastBar"] then
            CreateCastBar("TargetCastBar", "target")
        end
        if not _G["FocusCastBar"] then
            CreateCastBar("FocusCastBar", "focus")
        end

        if MSUF_ReanchorTargetCastBar then MSUF_ReanchorTargetCastBar() end
        if MSUF_ReanchorFocusCastBar  then MSUF_ReanchorFocusCastBar()  end
        if MSUF_ReanchorPlayerCastBar then MSUF_ReanchorPlayerCastBar() end
        if MSUF_UpdateCastbarVisuals  then MSUF_UpdateCastbarVisuals()  end
        if MSUF_UpdateCastbarTextures then MSUF_UpdateCastbarTextures() end

end

function MSUF_CastbarDriver_OnEnteringWorld(event)
        if TargetFrameSpellBar then
            TargetFrameSpellBar:UnregisterAllEvents()
            TargetFrameSpellBar:Hide()
            TargetFrameSpellBar:HookScript("OnShow", function(bar)
                bar:Hide()
            end)
        end

        if FocusFrameSpellBar then
            FocusFrameSpellBar:UnregisterAllEvents()
            FocusFrameSpellBar:Hide()
            FocusFrameSpellBar:HookScript("OnShow", function(bar)
                bar:Hide()
            end)
        end

        if PetCastingBarFrame then
            PetCastingBarFrame:UnregisterAllEvents()
            PetCastingBarFrame:Hide()
            PetCastingBarFrame:HookScript("OnShow", function(bar)
                bar:Hide()
            end)
        end

        if MSUF_EventBus_Unregister then
            MSUF_EventBus_Unregister("PLAYER_ENTERING_WORLD", "MSUF_CASTBAR_DRIVER_WORLD")
        end
end

MSUF_EventBus_Register("PLAYER_LOGIN", "MSUF_CASTBAR_DRIVER_LOGIN", MSUF_CastbarDriver_OnLogin, nil, true)
MSUF_EventBus_Register("PLAYER_ENTERING_WORLD", "MSUF_CASTBAR_DRIVER_WORLD", MSUF_CastbarDriver_OnEnteringWorld)

-- Optional export (debug / other modules)
_G.MSUF_CreateCastBar = CreateCastBar